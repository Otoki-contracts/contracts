
// superの役割とか結局分からないままJNFTを発行することになりそう。
// というのもJNFTはダイヤモンド承継を結局使わなかったから。

// けど、以下に、備忘録として参照すべきサイトを載せておく。







// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;


import "./extensions/ERC721URIStorage.sol";
import "../../access/Ownable.sol";





// superについての説明。なんかcontract JugglingNFT is ERC721, ERC721URIStorageの順番を変えちゃいけないらしい。
// https://bc.shuntak.net/2018/12/solidity-multiple-inheritance.html
contract JugglingNFT is ERC721, ERC721URIStorage, Ownable {
  uint256 internal nextTokenId = 0;
  uint256 public donatedAmount = 0.001 ether;
  
//   alreadyDonated[tokenId]をtransferFromのトリガーとして利用することを想定している。
//  =0ならNFTの送信不可。募金後、=1になったらNFTの送金を可にする。
   mapping (uint256 => bool) private alreadyDonated;
  
//   https://www.huobi.co.jp/ja-jp/donation/　huobi japanが行っている首里城復旧募金のアドレス。
// 　本当に送れるか試してみて。
  address charityAddress = 0x9C388AFbc760E19CfA9190F60E0e641b7D053e4a;
  
  
//   このサイト見た。_burnを定義する必要があるのは、ERC721とERC721URIStorageに_burnがあるからに過ぎないと思う。
// https://forum.openzeppelin.com/t/how-do-inherit-from-erc721-erc721enumerable-and-erc721uristorage-in-v4-of-openzeppelin-contracts/6656/2
  constructor() ERC721("JugglingNFT", "JNFT") {}

  
// ERC721の_burnとERC721URIStorageの_burnのどちらも承継している。superについてのダイヤモンド承継の仕方はちょっとよく分からないものの、
// _burnの機能それ自体はどちらもあまり変わらないため、どちらでも良いと言えばどちらでも良い。
// ERC721URIStorageの_burnはtokenURIもburnしてくれるという違いがあるだけです。
// てかなんならERC721URIStorageいらないのでは。。。

// そもそもburn機能いらないので、これは消します。
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId) public view override (ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }
    
    // 一応onlyownerにした。NFT発行後、onlyOwnerがURIをセットすることができる。
    function setTokenURI(uint256 tokenId, string memory _tokenURI) public onlyOwner {
        _setTokenURI(tokenId, _tokenURI);
    }
    
    
//   寄付額はonlyOwnerが自由に決められる。ただし0.001ether以下に限る。
  function setDonatedAmount(uint256 _newDonatedAmount) public onlyOwner {
      require(0.001 ether >= _newDonatedAmount);
      donatedAmount = _newDonatedAmount;
  }
  
  function getDonatedAmount() public view returns(uint256) {
      return donatedAmount;
  }

// SafeMathを使うのがなんか嫌だったからrequire(nextTokenId + 1 > nexTokenId);使った。
// safeMatはopenzeppelinのopenzeppelin-contracts/contracts/utils/math/SafeMath.solにあったからそれを引っ張ってくると良いかもね。
  function mint() external onlyOwner {
    uint256 tokenId = nextTokenId;
    super._mint(msg.sender, tokenId);
    require(nextTokenId + 1 > nextTokenId);
    nextTokenId++;
  }
  
  
   //この関数を呼び出したアカウントから指定分のイーサが入る
	 // このときdeployボタンの上にある　VALUE欄の数字をいじることで送金できるETHの量を変更できることに注意！！！
  function donateAndTransfer(address from, address to, uint256 tokenId) external payable {
      require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
      require(msg.value >= donatedAmount);
      _transfer(from, to, tokenId);
  }
  
  function withdrawForCharity() external {
      payable(charityAddress).transfer(address(this).balance);
  }
  
//   寄付できる人はtokenIdの持ち主に限定しなかった。
// 持ち主に限定したのであれば、require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");を追加しよう。
  function donateBeforeTransfer(uint256 tokenId) external payable {
      require(msg.value >= donatedAmount);
      alreadyDonated[tokenId] = true;
  }
  
//   metamaskで募金しないでtransferFromしようとすると、デフォのガスリミット21000ではそもそもintrinsic gas too lowのエラーによってトランザクションの送信すらできない。
// また、ガスリミットを53000にすれば、トランザクションの送信自体はすることができるが、やはり募金していないので、requireによってトランザクションが失敗する。
// 参照　https://y-nakajo.hatenablog.com/entry/2018/01/26/173543#intrinsic-gas-too-low
  function transferFrom(address from, address to, uint256 tokenId) public virtual override {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
        require(alreadyDonated[tokenId]);
        
        alreadyDonated[tokenId] = false;
        _transfer(from, to, tokenId);
    }
    
    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
        
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
        require(alreadyDonated[tokenId]);
        
        alreadyDonated[tokenId] = false;
        _safeTransfer(from, to, tokenId, _data);
    }
    

  
// burn機能を追加しなくてもいいと思ったので消します。
//   function burn(uint256 tokenId) external onlyOwner {
//       //solhint-disable-next-line max-line-length
//     require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
//     super._burn(tokenId);
//   }
}
